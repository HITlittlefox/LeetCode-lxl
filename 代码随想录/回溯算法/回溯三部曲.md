### 回溯三部曲
1. **回溯函数模板返回值以及参数**
    1. 习惯是函数起名字为`backtracking`
    2. 函数返回值一般为`void`
    3. 一般是先写逻辑，然后需要什么参数，就填什么参数。
    4. 回溯函数伪代码如下：
        ```java
        void backtracking(参数)
        ```
2. **回溯函数终止条件**
    1. 回溯函数终止条件伪代码如下：
        ```java
        if (终止条件) {
            存放结果;
            return;
        }
        ```
3. 回溯搜索的遍历过程
    1. 回溯函数遍历过程伪代码如下：
        ```java
        for (选择：本层集合中元素(树中节点孩子的数量就是集合的大小)) {
            处理节点;
            backtracking(路径，选择列表); // 递归
            回溯，撤销处理结果
        }
        ```
    2. for 循环可以理解是横向遍历:
        1. for 循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个 for 循环就执行多少次。
    3. backtracking(递归)就是纵向遍历
        1. backtracking 这里自己调用自己，实现递归。
4. 回溯算法模板框架如下：
    ```java
    void backtracking(参数) {
        if (终止条件) {
            存放结果;
            return;
        }
        for (选择：本层集合中元素(树中节点孩子的数量就是集合的大小)) {
            处理节点;
            backtracking(路径，选择列表); // 递归
            回溯，撤销处理结果
        }
    }
    ```








### 回溯法解决的问题
组合问题：N 个数里面按一定规则找出 k 个数的集合
切割问题：一个字符串按一定规则有几种切割方式
子集问题：一个 N 个数的集合里有多少符合条件的子集
排列问题：N 个数按一定规则全排列，有几种排列方式
棋盘问题：N 皇后，解数独等等


### 本题还需要 startIndex 来控制 for 循环的起始位置，对于组合问题，什么时候需要 startIndex 呢？
我举过例子，如果是一个集合来求组合的话，就需要 startIndex，例如：77. 组合 (opens new window)，216. 组合总和 III (opens new window)。

如果是多个集合取组合，各个集合之间相互不影响，那么就不用 startIndex，例如：17. 电话号码的字母组合(opens new window)

注意以上我只是说求组合的情况，如果是排列问题，又是另一套分析的套路，后面我再讲解排列的时候就重点介绍。